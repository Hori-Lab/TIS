! force_bangle
!> @brief Calculate forces generated by bond-angle interaction

!subroutine force_bangle(irep, force_mp, force_mp_mgo, ene_unit)
subroutine force_bangle(irep, force_mp)

  use const_maxsize
  use const_physical
  use var_struct, only : xyz_mp_rep, imp2unit, &
                         nba, iba2mp, ba_nat, coef_ba, &
                         nunit_all, nmp_all
!  use var_mgo,    only : inmgo, iba2sysmbr_mgo
  use mpiconst

  implicit none

  integer,    intent(in)    :: irep
  real(PREC), intent(inout) :: force_mp(3, nmp_all)
!  real(PREC), intent(inout) :: ene_unit(nunit_all, nunit_all)
!  real(PREC), intent(inout) :: force_mp_mgo(3, nmp_all, inmgo%nstate_max_mgo, inmgo%nsystem_mgo)

  integer :: iba, imp1, imp2, imp3
!  integer :: iunit, junit, isys, istat
  integer :: ksta, kend
  real(PREC) :: c11, c21, c22, t3, co_theta
  real(PREC) :: for, dba
  real(PREC) :: efull
  real(PREC) :: force_21(3), force_32(3)
  real(PREC) :: v21(3), v32(3)
#ifdef MPI_PAR
  integer :: klen
#endif

  ! ----------------------------------------------------------------------
#ifdef MPI_PAR
  klen=(nba-1+npar_mpi)/npar_mpi
  ksta=1+klen*local_rank_mpi
  kend=min(ksta+klen-1,nba)
#ifdef MPI_DEBUG
  print *,"bangle       = ", kend-ksta+1
#endif
#else
  ksta = 1
  kend = nba
#endif
!$omp do private(imp1,imp2,imp3,v21,v32,c11,c22,c21, &
!$omp&           co_theta,dba,t3,for,force_21,force_32)
!!$omp&           efull,iunit,junit,isys,istat)
  do iba=ksta,kend

     if (coef_ba(1, iba) < ZERO_JUDGE .and. coef_ba(2, iba) < ZERO_JUDGE) cycle
     
     imp1 = iba2mp(1, iba)
     imp2 = iba2mp(2, iba)
     imp3 = iba2mp(3, iba)

     v21(1:3) = xyz_mp_rep(1:3, imp2, irep) - xyz_mp_rep(1:3, imp1, irep)
     v32(1:3) = xyz_mp_rep(1:3, imp3, irep) - xyz_mp_rep(1:3, imp2, irep)
     
     c11 = v21(1) * v21(1) + v21(2) * v21(2) + v21(3) * v21(3)
     c22 = v32(1) * v32(1) + v32(2) * v32(2) + v32(3) * v32(3)
     c21 = v32(1) * v21(1) + v32(2) * v21(2) + v32(3) * v21(3)
     
     co_theta = - c21 / sqrt(c11 * c22)

     if(co_theta > 1.0e0_PREC) then
        co_theta = 1.0e0_PREC
     else if(co_theta < -1.0e0_PREC) then
        co_theta = -1.0e0_PREC
     end if

     dba = acos(co_theta) - ba_nat(iba)
   
     t3 = c11 * c22 - c21**2
     if(t3 <= 1.0e0_PREC) then
        t3 = 1.0e0_PREC
     end if

     ! calc force
     for = 2.0e0_PREC * coef_ba(1, iba) * dba / sqrt(t3) - &
          coef_ba(2, iba) / sqrt(c11 * c22)
     force_21(1:3) = for * (v21(1:3) * (c21 / c11) - v32(1:3))
     force_32(1:3) = for * (v32(1:3) * (c21 / c22) - v21(1:3))
   
!     if(inmgo%i_multi_mgo == 0) then
        force_mp(1:3, imp1) = force_mp(1:3, imp1) - force_21(1:3)
        force_mp(1:3, imp2) = force_mp(1:3, imp2) + force_21(1:3) - force_32(1:3)
        force_mp(1:3, imp3) = force_mp(1:3, imp3) + force_32(1:3)

!     else
!        ! calc energy
!        efull = coef_ba(1, iba) * dba**2
!        iunit = imp2unit(imp1)
!        junit = imp2unit(imp3)
!        ene_unit(iunit, junit) = ene_unit(iunit, junit) + efull
!
!        isys = iba2sysmbr_mgo(1, iba)
!        if(isys == 0) then
!           force_mp(1:3, imp1) = force_mp(1:3, imp1) - force_21(1:3)
!           force_mp(1:3, imp2) = force_mp(1:3, imp2) + force_21(1:3) - force_32(1:3)
!           force_mp(1:3, imp3) = force_mp(1:3, imp3) + force_32(1:3)
!        else
!           istat = iba2sysmbr_mgo(2, iba)
!           force_mp_mgo(1:3, imp1, istat, isys) = force_mp_mgo(1:3, imp1, istat, isys) - force_21(1:3)
!           force_mp_mgo(1:3, imp2, istat, isys) = force_mp_mgo(1:3, imp2, istat, isys) + force_21(1:3) - force_32(1:3)
!           force_mp_mgo(1:3, imp3, istat, isys) = force_mp_mgo(1:3, imp3, istat, isys) + force_32(1:3)
!        end if
!     end if

  end do
!$omp end do nowait

end subroutine force_bangle
