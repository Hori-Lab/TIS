! force_nlocal_mgo
!> @brief Calculate forces generated by non-local Go potential for &
!>        multiple-basin model. That means the forces are calculated &
!>        for all the states, and these forces will be combined in &
!>        another subroutine, force_mgo

! ************************************************************************
! formula of go1210
! ego = coef_go * {5*(go_nat/x)**12 -6*(go_nat/x)**10}
! coef_go = icon_dummy_mgo * factor_go * cgo1210
!
! parameter list
! cgo1210: constant of go energy
! factor_go: value of amino acid specifity (ex. 1.0, MJ)
! go_nat: distance of native contact 
! ************************************************************************
subroutine force_nlocal_mgo(irep, force_mp, force_mp_mgo, ene_unit)
  
  use const_maxsize
  use const_physical
  use const_index
  use var_setp,   only : inpro, inperi
  use var_struct, only : xyz_mp_rep, pxyz_mp_rep, imp2unit, &
                         ncon, icon2mp, coef_go, go_nat2, nunit_all, nmp_all
  use var_mgo,    only : ncontype_mgo, irefcon_mgo, icon2sysmbr_mgo, inmgo
  use mpiconst

  implicit none

  integer,    intent(in)  :: irep
  real(PREC), intent(inout) :: force_mp(3, nmp_all), ene_unit(nunit_all, nunit_all)
  real(PREC), intent(inout) :: force_mp_mgo(3, nmp_all, &
                                            inmgo%nstate_max_mgo, inmgo%nsystem_mgo)
! real(PREC), intent(inout) :: force_mp_mgo(3, inmgo%i_multi_mgo*nmp_all, &
!                                           inmgo%nstate_max_mgo, inmgo%nsystem_mgo)

  integer :: ksta, kend
  integer :: imp1, imp2, iunit, junit, isys, istat
  integer :: icon
  integer :: jcon = 1
  integer :: iswitch, imirror
  real(PREC) :: dist2
  real(PREC) :: cut_off
  real(PREC) :: dgo_dr, pre5over6
  real(PREC) :: sigma1, sigma2, gorad2
  real(PREC) :: d2   = 0.0e0_PREC
  real(PREC) :: pre1 = 0.0e0_PREC
  real(PREC) :: pre2 = 0.0e0_PREC
  real(PREC) :: gorad2j = 0.0e0_PREC
  real(PREC) :: rovdist2, rovdist12, rovdist14
  real(PREC) :: for(3), v21(3)
  real(PREC) :: efull, rovdist10
  character(CARRAY_MSG_ERROR) :: error_message
#ifdef MPI_PAR
  integer :: klen
#endif

  ! ---------------------------------------------------------------------
  cut_off = inpro%cutoff_go**2
  
  pre5over6 = 5.0e0_PREC / 6.0e0_PREC

#ifdef MPI_PAR
  klen=(ncon-1+npar_mpi)/npar_mpi
  ksta=1+klen*local_rank_mpi
  kend=min(ksta+klen-1,ncon)
#ifdef MPI_DEBUG
  print *,"nlocal_mgo   = ", kend-ksta+1
#endif
#else
  ksta = 1
  kend = ncon
#endif
!$omp do private(imp1,imp2,v21,dist2,gorad2,iswitch,jcon,gorad2j, &
!$omp&           sigma2,sigma1,pre1,pre2,rovdist2,rovdist14, &
!$omp&           rovdist12,rovdist10,d2,error_message,efull, &
!$omp&           iunit,junit,dgo_dr,for,isys,istat,imirror)
  do icon=ksta,kend

     imp1 = icon2mp(1, icon)
     imp2 = icon2mp(2, icon)

     if(inperi%i_periodic == 0) then
        v21(1:3) = xyz_mp_rep(1:3, imp2, irep) - xyz_mp_rep(1:3, imp1, irep)
     else
        v21(1:3) = pxyz_mp_rep(1:3, imp2, irep) - pxyz_mp_rep(1:3, imp1, irep)
        call util_pbneighbor(v21, imirror)
     end if
     
!     v21(1:3) = xyz_mp_rep(1:3, imp2, irep) - xyz_mp_rep(1:3, imp1, irep)

     dist2 = v21(1)*v21(1) + v21(2)*v21(2) + v21(3)*v21(3)

     gorad2 = go_nat2(icon)

     ! calc iswitch
     iswitch = 0
     if(ncontype_mgo(icon) == 0) then
        iswitch = 1
     else if(ncontype_mgo(icon) == 1 .or. &
          ncontype_mgo(icon) == 2) then
        jcon = irefcon_mgo(icon)
        gorad2j = go_nat2(jcon)
        sigma2 = pre5over6 * gorad2j       
        if(ncontype_mgo(icon) == 1) then
           sigma1 = pre5over6 * gorad2                  
           if(dist2 < sigma2) then
              iswitch = 2
           else if(dist2 >= sigma2 .and. dist2 <= sigma1) then
              iswitch = 3
           else
              iswitch = 1
           end if
        else if(ncontype_mgo(icon) == 2) then
           if(dist2 < sigma2) then
              iswitch = 2
           else
              iswitch = 3
           end if
        end if
     end if
     
     if(iswitch == 1) then
        !add IF sentence for rna around here, if cutoff_go for rna is different from that for protein (Now such IF sentence is not added because by default both are same)
!!        cut_off2 = gorad2 * cut_off
!!       if(dist2 > cut_off2) cycle
!! Lines with two !! will be turned on when we get confident or convinced of ignoring the inconsistency with previous go.chk results of multiple go simulation.
        pre1 = 60.0e0_PREC * coef_go(icon)
        pre2 = coef_go(icon)
        rovdist2 = gorad2 / dist2
        call dist14_12_10(rovdist2, rovdist14, rovdist12, rovdist10) 
        d2 = gorad2
     else if(iswitch == 2) then
!        pre1 = 60.0e0_PREC * coef_go(icon)
!        pre2 = coef_go(icon)
!!        cut_off2 = gorad2j * cut_off
!!        if(dist2 > cut_off2) cycle
 
        pre1 = 60.0e0_PREC * coef_go(jcon)  !AICG2
        pre2 = coef_go(jcon)                !AICG2
        rovdist2 = gorad2j / dist2
        call dist14_12_10(rovdist2, rovdist14, rovdist12, rovdist10) 
        d2 = gorad2j
     else if(iswitch == 3) then
        cycle
     else
        error_message = 'Error: invalid value for iswitch in force_nlocal_mgo'
        call util_error(ERROR%STOP_ALL, error_message)
     end if

     efull = pre2 * (5.0e0_PREC * rovdist12 - 6.0e0_PREC * rovdist10)
     iunit = imp2unit(imp1)
     junit = imp2unit(imp2)
     ene_unit(iunit, junit) = ene_unit(iunit, junit) + efull     
     
     dgo_dr = (pre1 / d2) * (rovdist14 - rovdist12)

     if(dgo_dr > DE_MAX) then
!        write (*, *) "mgo", imp1, imp2, dgo_dr
        dgo_dr = DE_MAX
     end if
!     if(dgo_dr > 5.0e0_PREC) dgo_dr = 5.0e0_PREC
     for(1:3) = dgo_dr * v21(1:3)   
    
     isys = icon2sysmbr_mgo(1, icon)
     if(isys == 0) then
        force_mp(1:3, imp1) = force_mp(1:3, imp1) - for(1:3)
        force_mp(1:3, imp2) = force_mp(1:3, imp2) + for(1:3)
     else
        istat = icon2sysmbr_mgo(2, icon)
        force_mp_mgo(1:3, imp1, istat, isys) = force_mp_mgo(1:3, imp1, istat, isys) - for(1:3)
        force_mp_mgo(1:3, imp2, istat, isys) = force_mp_mgo(1:3, imp2, istat, isys) + for(1:3)
     end if
     
  end do
!$omp end do nowait
  
  ! *********************************************************************    
contains

  ! ********************************************************************* 
  subroutine dist14_12_10(dist2, dist14, dist12, dist10)

    implicit none

    ! ------------------------------------------------------------------
    real(PREC), intent(in) :: dist2
    real(PREC), intent(out) :: dist14, dist12, dist10

    ! ------------------------------------------------------------------
    ! local variables
    real(PREC) :: dist4, dist8
    
    dist4 = dist2 * dist2
    dist8 = dist4 * dist4
    dist10 = dist2 * dist8
    dist12 = dist4 * dist8
    dist14 = dist12 * dist2
          
  end subroutine dist14_12_10

end subroutine force_nlocal_mgo


