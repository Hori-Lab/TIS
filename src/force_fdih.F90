! force_dih
!> @brief Calculate forces generated by dihedral angle term

subroutine force_fdih(irep, force_mp, force_mp_mgo, ene_unit)

  use const_maxsize
  use const_index
  use const_physical 
  use var_struct, only : nfdih, ifdih2mp, iclass_mp, nmp_all, nunit_all, fdih_para
  use var_mgo, only : inmgo
  use var_flp
  !use var_flp, only : phi_related

#ifdef MPI_PAR
  use mpiconst
#endif

  implicit none
  
  ! ----------------------------------------------------------------------
  integer,    intent(in)    :: irep
  real(PREC), intent(inout) :: force_mp(3, nmp_all), ene_unit(nunit_all, nunit_all)
  real(PREC), intent(inout) :: force_mp_mgo(3, nmp_all, &
                                           inmgo%nstate_max_mgo, inmgo%nsystem_mgo)
  ! real(PREC), intent(inout) :: force_mp_mgo(3, inmgo%i_multi_mgo*nmp_all, &
  !                                         inmgo%nstate_max_mgo, inmgo%nsystem_mgo)

  ! ----------------------------------------------------------------------
  ! local variables
  type(phi_related_variables) :: phi_related
  integer :: ksta, kend
  integer :: idih, i
  integer :: imp(4)
  real(PREC) :: theta1, theta2
#ifdef MPI_PAR
  integer :: klen
#endif

  ! ----------------------------------------------------------------------

#ifdef MPI_PAR
  klen=(nfdih-1+npar_mpi)/npar_mpi
  ksta=1+klen*local_rank_mpi
  kend=min(ksta+klen-1,nfdih)
#else
  ksta = 1
  kend = nfdih
#endif
!$omp do private(i, imp, phi_related)  
  do idih=ksta, kend

     ! -------------------------------------------------------------------
     ! calc dih angle

     ! Get ith mass points' ID
     do i = 1, 4
        imp(i) = ifdih2mp(i, idih)
     end do

     ! Check ith mass points' type        
     if(iclass_mp(imp(1)) == CLASS%LIG .AND. &
          iclass_mp(imp(4)) == CLASS%LIG) cycle

     ! Calculate two theta
     !call calc_theta(theta1, irep, imp(1), imp(2), imp(3))
     !call calc_theta(theta2, irep, imp(2), imp(3), imp(4))

     !call calc_u(u1, theta1)
     !call calc_u(u2, theta2)
     
     ! Calculate phi, normal vectors, size of them, and vector between each particle
     call calc_phi(phi_related, irep, imp)

     ! Calculate force
     call calc_force_fdih(phi_related, 1.0e0_PREC, 0.0e0_PREC, fdih_para(2, idih), imp, force_mp, force_mp_mgo, idih) !flp_mgo
     call calc_force_fdih(phi_related, 1.0e0_PREC, F_PI/2.0e0_PREC, fdih_para(3, idih), imp, force_mp, force_mp_mgo, idih) !flp_mgo
     call calc_force_fdih(phi_related, 2.0e0_PREC, 0.0e0_PREC, fdih_para(4, idih), imp, force_mp, force_mp_mgo, idih) !flp_mgo
     call calc_force_fdih(phi_related, 2.0e0_PREC, F_PI/2.0e0_PREC, fdih_para(5, idih), imp, force_mp, force_mp_mgo, idih) !flp_mgo
     call calc_force_fdih(phi_related, 3.0e0_PREC, 0.0e0_PREC, fdih_para(6, idih), imp, force_mp, force_mp_mgo, idih) !flp_mgo
     call calc_force_fdih(phi_related, 3.0e0_PREC, F_PI/2.0e0_PREC, fdih_para(7, idih), imp, force_mp, force_mp_mgo, idih) !flp_mgo

     ! Calculate bond angle force
     !call calc_force_ba(phi_related, irep, imp, idih, u1, u2, force_mp)
  end do
!$omp end do nowait

  contains
  ! ----------------------------------------------------------------------
  ! Subroutine for caluculation of phi
  ! ----------------------------------------------------------------------
  subroutine calc_theta(theta, irep, imp1, imp2, imp3)
    use const_maxsize
    use var_struct, only : xyz_mp_rep
    !use var_flp
    
    implicit none
    
    ! ----------------------------------------------------------------------
    ! Arguments
    real(PREC), intent(inout) :: theta
    integer, intent(in) :: irep, imp1, imp2, imp3
    
    ! ----------------------------------------------------------------------
    ! Local variables
    real(PREC) :: v21(3), v32(3)
    real(PREC) :: c11, c22, c21
    real(PREC) :: co_theta
    
    ! ----------------------------------------------------------------------
    ! Calculate bond angle
    
    v21(1:3) = xyz_mp_rep(1:3, imp2, irep) - xyz_mp_rep(1:3, imp1, irep)
    v32(1:3) = xyz_mp_rep(1:3, imp3, irep) - xyz_mp_rep(1:3, imp2, irep)
    
    c11 = v21(1) * v21(1) + v21(2) * v21(2) + v21(3) * v21(3)
    c22 = v32(1) * v32(1) + v32(2) * v32(2) + v32(3) * v32(3)
    c21 = v32(1) * v21(1) + v32(2) * v21(2) + v32(3) * v21(3)
    
    co_theta = - c21 / sqrt(c11 * c22)
    
    if(co_theta > 1.0e0_PREC) then
       co_theta = 1.0e0_PREC
    else if(co_theta < -1.0e0_PREC) then
       co_theta = -1.0e0_PREC
    end if
    
    theta = acos(co_theta)
    
  end subroutine calc_theta

  subroutine calc_u(u, theta)
    use const_maxsize
    use const_physical

    implicit none

    ! ----------------------------------------------------------------------
    ! Arguments
    real(PREC), intent(inout) :: u
    real(PREC), intent(in) :: theta

    ! ----------------------------------------------------------------------
    ! Local variables
    real(PREC) :: a, b
    
    ! ----------------------------------------------------------------------
    ! Calculate bond angle
    a = 1.0e0_PREC / (FDIH_DEL_MAX_ANG - FDIH_DEL_MIN_ANG)
    b = a * FDIH_DEL_MAX_ANG

    if (theta <= FDIH_DEL_MIN_ANG) then
       u = 1.0e0_PREC
    else if ( theta > FDIH_DEL_MIN_ANG .and. theta <= FDIH_DEL_MAX_ANG ) then
       u = -a * theta + b
       write (*, *) "Warning: u: ", u
    else if ( theta > FDIH_DEL_MAX_ANG ) then
       u = 0.0
       write (*, *) "Warning: u: ", u
    end if
       
  end subroutine calc_u

  ! ----------------------------------------------------------------------
  ! Subroutine for caluculation of phi
  ! ----------------------------------------------------------------------
  subroutine calc_phi(phi_related, irep, imp)
    use const_maxsize
    use var_struct, only : xyz_mp_rep
    use var_flp
        
    implicit none
    
    ! ----------------------------------------------------------------------
    ! Arguments
    type(phi_related_variables), intent(inout) :: phi_related
    integer, intent(in) :: irep, imp(4)
    
    ! ----------------------------------------------------------------------
    ! Local variables
    real(PREC) :: cos_phi
    real(PREC) :: vmvn, vmvm, vnvn
    real(PREC) :: sign
    real(PREC) :: rkj, rkj2
    real(PREC) :: a, b, p, q
    
    ! ----------------------------------------------------------------------
    ! Calculate dihedral angle
    
    ! Calculate internal vector
    phi_related%vij(1:3) = xyz_mp_rep(1:3, imp(1), irep) - xyz_mp_rep(1:3, imp(2), irep)
    phi_related%vkj(1:3) = xyz_mp_rep(1:3, imp(3), irep) - xyz_mp_rep(1:3, imp(2), irep)
    phi_related%vkl(1:3) = xyz_mp_rep(1:3, imp(3), irep) - xyz_mp_rep(1:3, imp(4), irep)
    
    ! Calculate normal vectors
    call calc_cross_product(phi_related%vm, phi_related%vij, phi_related%vkj)
    call calc_cross_product(phi_related%vn, phi_related%vkj, phi_related%vkl)
    
    ! Calculate dot product of vm and vn
    call calc_dot_product(vmvn, phi_related%vm, phi_related%vn)
    call calc_dot_product(vmvm, phi_related%vm, phi_related%vm)
    call calc_dot_product(vnvn, phi_related%vn, phi_related%vn)
    
    ! Calculate size of normal vectors
    phi_related%rm = vmvm
    phi_related%rn = vnvn

    call calc_dot_product(rkj2, phi_related%vkj, phi_related%vkj)
    rkj = sqrt(rkj2)
    a = rkj / phi_related%rm
    b = rkj / phi_related%rn
    call calc_dot_product(p, phi_related%vij, phi_related%vkj)
    phi_related%p = p / rkj2
    call calc_dot_product(q, phi_related%vkl, phi_related%vkj)
    phi_related%q = q / rkj2
    
    phi_related%vfi(:) = a * phi_related%vm(:)
    phi_related%vfl(:) = b * phi_related%vn(:)
    
    ! Calculate cos(phi)
    cos_phi = vmvn / ( sqrt(phi_related%rm) * sqrt(phi_related%rn) )
    
    if(cos_phi > 1.0e0_PREC) then
       cos_phi = 1.0e0_PREC
    else if(cos_phi < -1.0e0_PREC) then
       cos_phi = -1.0e0_PREC
    end if
    
    phi_related%phi = acos(cos_phi);
    
    call calc_dot_product (sign, phi_related%vij, phi_related%vn)
    
    if (sign < 0.0e0_PREC) then
       phi_related%phi = phi_related%phi * (-1.0e0_PREC)
    end if
    
  end subroutine calc_phi
  
  ! ----------------------------------------------------------------------
  ! Subroutine for caluculation of cross product
  ! ----------------------------------------------------------------------
  subroutine calc_cross_product(cross_product, vector1, vector2)
    
    use const_maxsize
    
    implicit none
    
    ! ----------------------------------------------------------------------
    ! Arguments
    real(PREC), intent(inout) :: cross_product(3)
    real(PREC), intent(in) :: vector1(3), vector2(3)
    
    cross_product(1) = vector1(2) * vector2(3) - vector1(3) * vector2(2);
    cross_product(2) = vector1(3) * vector2(1) - vector1(1) * vector2(3);
    cross_product(3) = vector1(1) * vector2(2) - vector1(2) * vector2(1);
    
  end subroutine calc_cross_product

  ! ----------------------------------------------------------------------
  ! Subroutine for caluculation of dot product
  ! ----------------------------------------------------------------------
  subroutine calc_dot_product(dot_product, vector1, vector2)
    
    use const_maxsize
    
    implicit none
    
    ! ----------------------------------------------------------------------
    ! Arguments
    real(PREC), intent(inout) :: dot_product
    real(PREC), intent(in) :: vector1(3)
    real(PREC), intent(in) :: vector2(3)
    
    ! ----------------------------------------------------------------------
    ! Local variables
    integer :: i
    
    dot_product = 0.0E0_PREC
    
    do i = 1, 3
       dot_product = dot_product + ( vector1(i) * vector2(i) )
    end do
    
  end subroutine calc_dot_product

  ! ----------------------------------------------------------------------
  ! Subroutine for caluculation of force
  ! ----------------------------------------------------------------------
  subroutine calc_force_fdih(phi_related, coeff_of_phi, phase_of_phi, param, imp, force_mp, force_mp_mgo, idih) !flp_mgo
    
    use const_maxsize
    use var_mgo, only : inmgo, idih2sysmbr_mgo   !flp_mgo
    use var_setp, only : inflp
    use var_struct, only : nmp_all, ifdih2dih !flp_mgo
    use var_flp
        
    implicit none
    
    ! ----------------------------------------------------------------------
    ! Arguments
    type(phi_related_variables), intent(in)    :: phi_related
    real(PREC)                 , intent(in)    :: coeff_of_phi ! coefficient of phi
    real(PREC)                 , intent(in)    :: phase_of_phi ! phase of phi
    real(PREC)                 , intent(in)    :: param ! parameter
    integer                    , intent(in)    :: imp(4)
    real(PREC)                 , intent(inout) :: force_mp(3, nmp_all)
    integer                    , intent(in)    :: idih !flp_mgo
    real(PREC), intent(inout) :: force_mp_mgo(3, nmp_all, &
                                             inmgo%nstate_max_mgo, inmgo%nsystem_mgo)  !flp_mgo 
    ! ----------------------------------------------------------------------
    ! Local variables
    integer :: isys, istat !flp_mgo
    real(PREC) :: cphi ! coeff * phi - phase
    real(PREC) :: sin_cphi ! sin(coeff * phi - phase)
    real(PREC) :: param_sin_cphi ! parameter * coeff * sin(coeff * phi - phase)
    !real(PREC) :: rkj, rkj2
    !real(PREC) :: a, p, q
    real(PREC) :: vfi(3), vfj(3), vfk(3), vfl(3), uvec(3), vvec(3), svec(3)
    
    ! ----------------------------------------------------------------------
    ! Calculate dih force
    cphi = coeff_of_phi * phi_related%phi - phase_of_phi
    sin_cphi = sin(cphi)
    param_sin_cphi = -param * coeff_of_phi * sin_cphi
    
    !call calc_dot_product(rkj2, phi_related%vkj, phi_related%vkj)
    !rkj = sqrt(rkj2)
    
    !a = -param_sin_cphi * rkj / phi_related%rm
    !vfi(:) = a * phi_related%vm(:)
    
    !call calc_dot_product(p, phi_related%vij, phi_related%vkj)
    !p = p / rkj2
    
    !call calc_dot_product(q, phi_related%vkl, phi_related%vkj)
    !q = q / rkj2

    vfi(:) = -param_sin_cphi * phi_related%vfi(:)
    vfl(:) =  param_sin_cphi * phi_related%vfl(:)
        
    uvec(:) = phi_related%p * vfi(:)
    vvec(:) = phi_related%q * vfl(:)
    svec(:) = uvec(:) - vvec(:)
    
    vfj(:) = vfi(:) - svec(:)
    vfk(:) = vfl(:) + svec(:)
    
    ! ----------------------------------------------------------------------
    ! Increment forces
    if (inmgo%i_multi_mgo == 0) then
       !force_mp(1:3, imp(4)) = force_mp(1:3, imp(4)) + u1 * u2 * inflp%k_dih * vfl(1:3)
       !force_mp(1:3, imp(1)) = force_mp(1:3, imp(1)) + u1 * u2 * inflp%k_dih * vfi(1:3)
       !force_mp(1:3, imp(2)) = force_mp(1:3, imp(2)) - u1 * u2 * inflp%k_dih * vfj(1:3)
       !force_mp(1:3, imp(3)) = force_mp(1:3, imp(3)) - u1 * u2 * inflp%k_dih * vfk(1:3)
       force_mp(1:3, imp(4)) = force_mp(1:3, imp(4)) + inflp%k_dih * vfl(1:3)
       force_mp(1:3, imp(1)) = force_mp(1:3, imp(1)) + inflp%k_dih * vfi(1:3)
       force_mp(1:3, imp(2)) = force_mp(1:3, imp(2)) - inflp%k_dih * vfj(1:3)
       force_mp(1:3, imp(3)) = force_mp(1:3, imp(3)) - inflp%k_dih * vfk(1:3)
    else
       ! TODO implement mgo treatment
     ! flp_mgo
        isys = idih2sysmbr_mgo(1, ifdih2dih(idih))
        if(isys == 0) then
           force_mp(1:3, imp(1)) = force_mp(1:3, imp(1)) + inflp%k_dih * vfi(1:3)
           force_mp(1:3, imp(2)) = force_mp(1:3, imp(2)) - inflp%k_dih * vfj(1:3)
           force_mp(1:3, imp(3)) = force_mp(1:3, imp(3)) - inflp%k_dih * vfk(1:3)
           force_mp(1:3, imp(4)) = force_mp(1:3, imp(4)) + inflp%k_dih * vfl(1:3)
        else
           istat = idih2sysmbr_mgo(2, ifdih2dih(idih))
           force_mp_mgo(1:3, imp(1), istat, isys) = force_mp_mgo(1:3, imp(1), istat, isys) + inflp%k_dih * vfi(1:3)
           force_mp_mgo(1:3, imp(2), istat, isys) = force_mp_mgo(1:3, imp(2), istat, isys) - inflp%k_dih * vfj(1:3)
           force_mp_mgo(1:3, imp(3), istat, isys) = force_mp_mgo(1:3, imp(3), istat, isys) - inflp%k_dih * vfk(1:3)
           force_mp_mgo(1:3, imp(4), istat, isys) = force_mp_mgo(1:3, imp(4), istat, isys) + inflp%k_dih * vfl(1:3)
        end if
    end if
    
  end subroutine calc_force_fdih
  
  subroutine calc_force_ba(phi_related, irep, imp, ifdih, u1, u2, force_mp)
    
    use const_maxsize
    use var_flp
    use var_struct, only: xyz_mp_rep, &
                          fdih_para, &
                          fdih_ener_corr
        
    implicit none
    
    ! ----------------------------------------------------------------------
    ! Arguments
    type(phi_related_variables), intent(in)    :: phi_related
    integer                    , intent(in)    :: irep
    integer                    , intent(in)    :: imp(4)
    integer                    , intent(in)    :: ifdih
    real(PREC)                 , intent(in)    :: u1, u2
    real(PREC)                 , intent(inout) :: force_mp(3, nmp_all)
    
    ! ----------------------------------------------------------------------
    ! Local variables
    real(PREC) :: offset
    
    real(PREC) :: v21(3), v32(3)
    real(PREC) :: c11, c22
    real(PREC) :: vfi_theta1(3), vfj_theta1(3), vfk_theta1(3)
    real(PREC) :: vfi_theta2(3), vfj_theta2(3), vfk_theta2(3)

    real(PREC) :: v_phi
    
    real(PREC) :: du1_theta1
    real(PREC) :: du2_theta2
        
    ! ----------------------------------------------------------------------
    ! Calculate bond angle force
    offset = 1.0e1_PREC    

    ! Calculate dtheta/dr
    v21(1:3) = xyz_mp_rep(1:3, imp(2), irep) - xyz_mp_rep(1:3, imp(1), irep)
    v32(1:3) = xyz_mp_rep(1:3, imp(3), irep) - xyz_mp_rep(1:3, imp(2), irep)
    
    c11 = v21(1) * v21(1) + v21(2) * v21(2) + v21(3) * v21(3)
    c22 = v32(1) * v32(1) + v32(2) * v32(2) + v32(3) * v32(3)
    
    vfi_theta1(:) = v32(:) * ( 1 / sqrt(c11) )
    vfj_theta1(:) = v21(:) * ( 1 / sqrt(c22) )
    vfk_theta1(:) = -( vfi_theta1(:) + vfk_theta1(:) )
    
    v21(1:3) = xyz_mp_rep(1:3, imp(3), irep) - xyz_mp_rep(1:3, imp(2), irep)
    v32(1:3) = xyz_mp_rep(1:3, imp(4), irep) - xyz_mp_rep(1:3, imp(3), irep)
    
    c11 = v21(1) * v21(1) + v21(2) * v21(2) + v21(3) * v21(3)
    c22 = v32(1) * v32(1) + v32(2) * v32(2) + v32(3) * v32(3)
    
    vfi_theta2(:) = v32(:) * ( 1 / sqrt(c11) )
    vfj_theta2(:) = v21(:) * ( 1 / sqrt(c22) )
    vfk_theta2(:) = -( vfi_theta2(:) + vfk_theta2(:) )
    
    ! Calculate V(phi)
    v_phi =  fdih_para(1, ifdih)                            &
           + fdih_para(2, ifdih) * cos(    phi_related%phi) &
           + fdih_para(3, ifdih) * sin(    phi_related%phi) &
           + fdih_para(4, ifdih) * cos(2 * phi_related%phi) &
           + fdih_para(5, ifdih) * sin(2 * phi_related%phi) &
           + fdih_para(6, ifdih) * cos(3 * phi_related%phi) &
           + fdih_para(7, ifdih) * sin(3 * phi_related%phi) &
           - fdih_ener_corr(ifdih)
    v_phi = v_phi - offset

    ! Calculate du1(theta1)/dthata1
    if (theta1 <= FDIH_DEL_MIN_ANG .or. theta1 > FDIH_DEL_MAX_ANG) then
       du1_theta1 = 0.0e0_PREC
    else if ( theta1 > FDIH_DEL_MIN_ANG .and. theta1 <= FDIH_DEL_MAX_ANG ) then
       du1_theta1 = -1.0e0_PREC / (FDIH_DEL_MAX_ANG - FDIH_DEL_MIN_ANG)
    end if

    ! Calculate du2(theta2)/dthata2
    if (theta2 <= FDIH_DEL_MIN_ANG .or. theta2 > FDIH_DEL_MAX_ANG) then
       du2_theta2 = 0.0e0_PREC
    else if ( theta2 > FDIH_DEL_MIN_ANG .and. theta2 <= FDIH_DEL_MAX_ANG ) then
       du2_theta2 = -1.0e0_PREC / (FDIH_DEL_MAX_ANG - FDIH_DEL_MIN_ANG)
    end if

    ! Increment force
    if (inmgo%i_multi_mgo == 0) then
       
       force_mp(1:3, imp(1)) = force_mp(1:3, imp(1)) + du1_theta1 * u2 * v_phi * vfi_theta1
       force_mp(1:3, imp(2)) = force_mp(1:3, imp(2)) + du1_theta1 * u2 * v_phi * vfj_theta1
       force_mp(1:3, imp(3)) = force_mp(1:3, imp(3)) + du1_theta1 * u2 * v_phi * vfk_theta1
       
       force_mp(1:3, imp(2)) = force_mp(1:3, imp(2)) + du2_theta2 * u1 * v_phi * vfi_theta2
       force_mp(1:3, imp(3)) = force_mp(1:3, imp(3)) + du2_theta2 * u1 * v_phi * vfj_theta2
       force_mp(1:3, imp(4)) = force_mp(1:3, imp(4)) + du2_theta2 * u1 * v_phi * vfk_theta2
       
    else
       ! TODO implement mgo treatment
    end if
    
  end subroutine calc_force_ba

end subroutine force_fdih

