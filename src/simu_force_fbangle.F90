! simu_force_bangle
!> @brief Calculate forces generated by bond-angle interaction

subroutine simu_force_fbangle(irep, force_mp, force_mp_mgo, ene_unit)

  use const_maxsize
  use const_physical
  use var_struct, only : nfba, ifba2mp, nmp_all, nunit_all, xyz_mp_rep, &
                         fba_max_th, fba_min_th, &
                         ifba2ba  !flp_mgo
  use var_mgo,    only : inmgo, iba2sysmbr_mgo
  use var_setp,   only : inflp
  
#ifdef MPI_PAR
  use mpiconst
#endif

  implicit none

  ! ----------------------------------------------------------------------
  integer,    intent(in)    :: irep
  real(PREC), intent(inout) :: force_mp(3, nmp_all), ene_unit(nunit_all, nunit_all)
  real(PREC), intent(inout) :: force_mp_mgo(3, nmp_all, &
                                            inmgo%nstate_max_mgo, inmgo%nsystem_mgo)

  ! ----------------------------------------------------------------------
  ! local variables
  integer :: ksta, kend
  integer :: isys, istat  !flp_mgo
  integer :: ifba, i
  integer :: imp(3)
  real(PREC) :: v21(3), v32(3)
  real(PREC) :: c11, c22, c21
  real(PREC) :: co_theta, theta, sin_theta
  real(PREC) :: force, force_i(3), force_j(3), force_k(3)
#ifdef MPI_PAR
  integer :: klen
#endif
  
  ! ----------------------------------------------------------------------

#ifdef MPI_PAR
  klen=(nfba-1+npar_mpi)/npar_mpi
  ksta=1+klen*local_rank_mpi
  kend=min(ksta+klen-1,nfba)
#ifdef MPI_DEBUG
  print *,"bangle       = ", kend-ksta+1
#endif
#else
  ksta = 1
  kend = nfba
#endif
!$omp do private(i, imp, v21, v32, c11, c22, c21, &
!$omp&           co_theta, theta, sin_theta, force, force_i, force_j, force_k, isys, istat)
  do ifba=ksta,kend

     ! Get ID of particle which forces will be calculated
     do i = 1, 3
        imp(i) = ifba2mp(i, ifba)
     end do

     ! Calculate theta
     v21(1:3) = xyz_mp_rep(1:3, imp(2), irep) - xyz_mp_rep(1:3, imp(1), irep)
     v32(1:3) = xyz_mp_rep(1:3, imp(3), irep) - xyz_mp_rep(1:3, imp(2), irep)

     c11 = v21(1) * v21(1) + v21(2) * v21(2) + v21(3) * v21(3)
     c22 = v32(1) * v32(1) + v32(2) * v32(2) + v32(3) * v32(3)
     c21 = v32(1) * v21(1) + v32(2) * v21(2) + v32(3) * v21(3)     
     
     co_theta = - c21 / sqrt(c11 * c22)

     if(co_theta > 1.0e0_PREC) then
        co_theta = 1.0e0_PREC
     else if(co_theta < -1.0e0_PREC) then
        co_theta = -1.0e0_PREC
     end if

     theta = acos(co_theta)

     if ( theta < fba_min_th(ifba) ) then
        force = FBA_MIN_ANG_FORCE
     else if ( theta > fba_max_th(ifba) ) then
        force = FBA_MAX_ANG_FORCE
     else
        call dsplint(theta, ifba, force)
     end if

     !if (theta < FBA_MIN_ANG) then
     !   write (*, *) "Warning: MIN: step: ", istep, " id: ", imp(1), imp(2), imp(3), " theta: ", theta
     !else if (theta > FBA_MAX_ANG) then
     !   write (*, *) "Warning: MAX: step: ", istep, " id: ", imp(1), imp(2), imp(3), " theta: ", theta
     !end if
     
     ! J. Chem. Software, Vol. 6, pp10
     sin_theta = sin(theta)
     force_i = -force / (sqrt(c11) * sin_theta) * ( -( v32 / sqrt(c22) ) - co_theta * (v21 / sqrt(c11) ) )
     force_k = -force / (sqrt(c22) * sin_theta) * (  ( v21 / sqrt(c11) ) + co_theta * (v32 / sqrt(c22) ) )
     force_j = -(force_i + force_k)

     ! ----------------------------------------------------------------------
     ! Increment forces
     if(inmgo%i_multi_mgo == 0) then
        force_mp(1:3, imp(1)) = force_mp(1:3, imp(1)) + inflp%k_ang * force_i
        force_mp(1:3, imp(2)) = force_mp(1:3, imp(2)) + inflp%k_ang * force_j
        force_mp(1:3, imp(3)) = force_mp(1:3, imp(3)) + inflp%k_ang * force_k
     else
        ! TODO implement mgo treatment
        ! flp_mgo
        isys = iba2sysmbr_mgo(1, ifba2ba(ifba))
        if(isys == 0) then
           force_mp(1:3, imp(1)) = force_mp(1:3, imp(1)) + inflp%k_ang * force_i
           force_mp(1:3, imp(2)) = force_mp(1:3, imp(2)) + inflp%k_ang * force_j
           force_mp(1:3, imp(3)) = force_mp(1:3, imp(3)) + inflp%k_ang * force_k
        else
           istat = iba2sysmbr_mgo(2, ifba2ba(ifba))
           force_mp_mgo(1:3, imp(1), istat, isys) = force_mp_mgo(1:3, imp(1), istat, isys) + inflp%k_ang * force_i
           force_mp_mgo(1:3, imp(2), istat, isys) = force_mp_mgo(1:3, imp(2), istat, isys) + inflp%k_ang * force_j
           force_mp_mgo(1:3, imp(3), istat, isys) = force_mp_mgo(1:3, imp(3), istat, isys) + inflp%k_ang * force_k
        end if
     end if
     
  end do
!$omp end do nowait

end subroutine simu_force_fbangle

subroutine dsplint(theta, ifba, force)
  
  use const_maxsize
  use const_physical
  use var_struct, only : fba_para_x, fba_para_y, fba_para_y2 
    
  implicit none
  
  ! ----------------------------------------------------------------------
  real(PREC), intent(in) :: theta
  integer, intent(in) :: ifba
  real(PREC), intent(inout) :: force
  
  ! ----------------------------------------------------------------------
  ! local variables
  integer :: n, klo, khi, k
  real(PREC) :: h, a, b
  ! ----------------------------------------------------------------------

  n = size(fba_para_x(:,1)) ! Get the number of bin
  
  klo = 1
  khi = n 

  do while (khi - klo > 1) 
     k = (khi+klo) / 2
     if ( fba_para_x(k, ifba) > theta) then
        khi = k;
     else
        klo = k;
     end if
  end do

  h = fba_para_x(khi, ifba) - fba_para_x(klo, ifba)

  a = ( fba_para_x(khi, ifba) - theta ) / h
  b = ( theta - fba_para_x(klo, ifba) ) / h

  force = ( fba_para_y(khi, ifba) - fba_para_y(klo, ifba) ) / h &
       + ( (3 * b**2 - 1) * fba_para_y2(khi, ifba) &
       -   (3 * a**2 - 1) * fba_para_y2(klo, ifba) ) * h / 6.0e0_PREC

end subroutine dsplint
